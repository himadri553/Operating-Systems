The ABA problem is a subtle concurrency bug that arises in lock-free algorithms when using 
atomic compare-and-swap (CAS) (or similar “read-then-compare-and-update” techniques). 
The rough scenario is:

1. Thread T1 reads a shared location (say, a pointer or a value) and sees the value A.
2. T1 is then paused or interleaved with other threads.
3. Another thread T2 changes the location from A to B, does some operations, and then returns it from B back to A.
4. T1 resumes, re-reads (or compares) the location, sees A again, and concludes “nothing changed,” and proceeds to do a CAS of “if it is A, set to new value C.” 
Because the value is A, its CAS succeeds — even though the location did change in the interim (to B and back).

Thus, T1 is “fooled” into believing nothing happened, while in fact the shared state may have undergone intervening changes. This can corrupt data structures or break invariants. 
The name “ABA” comes from the pattern: the value goes from 
A→B→A.

It becomes more of a problem when pointers are reused: e.g., an object at address X is freed, 
and a new object is allocated at the same address; a stale pointer referring to X might look “valid” again, but refers to a wholly different object.

The root is that CAS (or a compare) checks equality of the value, not “whether something changed in between.”


Sources:
1) Lecture slides from ETH Zürich explain the problem clearly in the context of a lock-free stack
https://spcl.inf.ethz.ch/Teaching/2020-pp/lectures/PP-l21-ConcurrencyTheory.pdf  
2) “Understanding and Effectively Preventing the ABA Problem” describes the problem in detail and how it corrupts nonblocking algorithms.
https://www.stroustrup.com/isorc2010.pdf
3) Standard illustration & explanation
https://en.wikipedia.org/wiki/ABA_problem
