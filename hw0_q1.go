/*
	Himadri Saha

	HW0 - Question 1

	Write a program in which you will create two processes:
	- A Producer process that generates and prints numbers
	- A Consumer process that consumes the numbers generated by the Producer.
	Here, “consume” means the Consumer “obtains” or “receives” the numbers from Producer (by some IPC), and prints the numbers on stdout.

	You will need to use inter-process communication to allow the Producer to pass data to the Consumer.
	The program will stop after the Producer generates and the Consumer consumes (prints) 5 numbers.
	Both processes should terminate gracefully, after its task is completed.

	Expected output:
	Producer: 1
	Consumer: 1
	Producer: 2
	Consumer: 2
	Producer: 3
	Consumer: 3
	Producer: 4
	Consumer: 4
	Producer: 5
	Consumer: 5

	Note: your output has to follow this order.
	Key concepts: process creation/termination, inter-process communication, and (simple) synchronization, producer-consumer pattern

	Process Outline:

*/

/*Imports and constants*/
package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"strconv"
)

const (
	roleFlag   = "--role=consumer" // role switching flag
	upperLimit = 5                 // upper limit of number
)

func main() {
	/*
		Main timeline
		1. os.Args = [./myProgram], if = false
		2. @ runProducer() cmd runs: ./myProgram --role=consumer, starting a new process
		3. os.Args = [./yourprogram --role=consumer], if = true: runConsumer()
		4. In parallel:
			Producer: #, sends # through stdin, waits for ACK
			read # from stdin, Consumer: 1, sends ACK to stderr
		5. @ num = 5, Producer closes pipes
	*/
	if len(os.Args) > 1 && os.Args[1] == roleFlag {
		runConsumer()
		return
	}
	runProducer()
}

/*
- create the consumer as the child process
- send numbers to consumer
- print
- wait for ack before continuing
- shut down cleanly
*/
func runProducer() {
	/*
		Initalize:
		- Command to run program as consumer
		- Pipe to write numbers to: StdinPipe
		- Pipe to read ACK: StderrPipe
	*/
	cmd := exec.Command(os.Args[0], roleFlag)
	consumerStdin, err := cmd.StdinPipe()
	check(err)
	consumerAck, err := cmd.StderrPipe()
	check(err)

	// Connect child process to the parent process (to print "Consumer: n" lines)
	cmd.Stdout = os.Stdout

	// Start consumer process
	check(cmd.Start())

	// Wrap the pipes with buffered I/O.
	writer := bufio.NewWriter(consumerStdin)
	ackReader := bufio.NewScanner(consumerAck)

	// Produce numbers 1..5 with strict rendezvous.
	for n := 1; n <= upperLimit; n++ {
		// Producer prints its line first.
		fmt.Printf("Producer: %d\n", n)

		// Send the number to the consumer as a line.
		_, err := writer.WriteString(strconv.Itoa(n) + "\n")
		check(err)
		check(writer.Flush())

		// Wait for an ACK line from consumer (read from child's stderr).
		if !ackReader.Scan() {
			// If the consumer exited or EOF before ACK, treat as an error.
			check(fmt.Errorf("consumer terminated before ACK for %d", n))
		}
		// (Optionally validate ackReader.Text() == "ACK")
	}

	// Close the consumer's stdin to signal no more data.
	check(consumerStdin.Close())

	// Wait for consumer to exit cleanly.
	check(cmd.Wait())
}

// runConsumer reads integers (as lines) from stdin,
// prints "Consumer: n" to stdout for each, then writes an "ACK" line to stderr.
func runConsumer() {
	// Readers/writers
	input := bufio.NewScanner(os.Stdin)
	stdout := bufio.NewWriter(os.Stdout)
	stderr := bufio.NewWriter(os.Stderr)

	for input.Scan() {
		line := input.Text()
		n, err := strconv.Atoi(line)
		if err != nil {
			// Ignore malformed lines; alternatively, exit with an error.
			continue
		}
		// Print consumer line to STDOUT (this is part of required program output).
		_, err = fmt.Fprintf(stdout, "Consumer: %d\n", n)
		if err != nil {
			// If we can't write output, bail.
			break
		}
		// Flush immediately to maintain ordering with producer prints.
		if err := stdout.Flush(); err != nil {
			break
		}
		// Send ACK on STDERR (separate channel so it doesn't pollute stdout).
		_, _ = fmt.Fprintln(stderr, "ACK")
		_ = stderr.Flush()
	}

	// Clean exit (ignore input.Scan error for simplicity).
}

// Error Helper
func check(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(1)
	}
}
